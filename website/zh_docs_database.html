<!DOCTYPE html>
<html lang="zh">
  <head>
    <script>var _sf_startpt=(new Date()).getTime()</script>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width">
    <title>KeystoneJS &middot; 设置和使用数据模型
    </title>
    <meta name="keywords" content="node.js,nodejs,cms,publishing,platform,web,development,framework,express,mongo,mongodb,bootstrap,react,jquery">
    <meta name="description" content="Get a head-start on the features you need. KeystoneJS is the easiest way to build dynamic websites, applications and APIs with Node.js and MongoDB.">
    <meta property="og:locale" content="en-us">
    <meta property="og:title" content="KeystoneJS">
    <meta property="og:description" content="KeystoneJS is an open source Node.js CMS and web application platform built on Express and MongoDB.">
    <meta property="og:url" content="https://keystonejs.com^current_url^">
    <meta property="og:site_name" content="KeystoneJS">
    <meta property="og:type" content="article">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,300italic,400,500,700" rel="stylesheet">
    <link href="/styles/site.min.css" rel="stylesheet">
    <link href="/styles/prism.css" rel="stylesheet">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  </head>
  <body>
    <div class="language-switcher">
      <div class="container"><a href="/zh/docs" class="active language-switcher-option">中文 (Chinese)</a><a href="/docs" class="language-switcher-option">English</a></div>
    </div>
    <header role="banner" class="docs-header">
      <div class="container">
        <button type="button" data-toggle="collapse" data-target=".docs-nav__collapse" class="navbar-toggle navbar-toggle-menu"><span class="sr-only">锁定导航栏</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
        </button><a href="/zh/" title="KeystoneJS" class="keystone-logo"><img src="/images/logo.svg" alt="KeystoneJS" width="207" height="70"></a>
        <nav class="docs-nav">
          <div class="docs-nav__collapse collapse">
            <ul class="docs-nav__nav">
              <li><a href="/zh">首页</a></li>
              <li><a href="/zh/getting-started">入门指南</a></li>
              <li class="active"><a href="/zh/docs">文档</a></li>
              <li><a href="/zh/examples">范例</a></li>
            </ul>
          </div>
        </nav>
      </div>
    </header>
    <div class="page-header">
      <div class="container">
        <h1>数据库</h1>
        <p class="lead">数据模型的设置及使用</p>
      </div>
    </div>
    <div class="docs-body">
      <div class="container">
        <div class="row">
          <div class="col-sm-3">
            <div class="visible-xs">
              <ul class="nav-toggle">
                <li><a href="/zh/docs/getting-started" class="nav-heading">入门</a></li>
                <li><a href="/zh/docs/configuration" class="nav-heading">配置</a></li>
                <li class="active"><a href="/zh/docs/database" class="nav-heading">数据库</a></li>
              </ul>
            </div>
            <nav class="docs-sidebar hidden-xs">
              <ul class="sidebar-nav">
                <li><a href="/zh/docs" class="nav-heading">欢迎</a></li>
                <li><a href="/zh/docs/getting-started" class="nav-heading">入门指南</a></li>
                <li><a href="/zh/docs/configuration" class="nav-heading">配置</a></li>
                <li class="active"><a href="/zh/docs/database" class="nav-heading">数据库</a></li>
              </ul>
              <hr/>
              <ul class="sidebar-nav">
                <ul>
                  <li class="nav-label"><a href="#concepts">概念</a></li>
                  <li class="nav-label"><a href="#lists">列表</a></li>
                  <li><a href="#lists-usage">用法</a></li>
                  <li><a href="#lists-example">示例</a></li>
                  <li><a href="#lists-options">List参数</a></li>
                  <li><a href="#lists-plugins">Schema插件</a></li>
                  <li><a href="#lists-querying">查询数据</a></li>
                  <li><a href="#lists-paginate">分页查询</a></li>
                  <li><a href="#lists-creating">创建条目</a></li>
                  <li><a href="#lists-deleting">删除条目</a></li>
                  <li class="nav-label"><a href="#headings">标题</a></li>
                  <li class="nav-label"><a href="#fields">域</a></li>
                  <li><a href="#fields-overview">概览</a></li>
                  <li><a href="#fields-options">域参数</a></li>
                  <li><a href="#fields-conditional">域条件</a></li>
                  <li><a href="#fields-watching">域监听</a></li>
                  <li><a href="#fields-underscoremethods">Underscore方法</a></li>
                  <li class="nav-label"><a href="#relationships">关系</a></li>
                  <li><a href="#relationship-fields">关系域</a></li>
                  <li><a href="#relationship-definitions">关系定义</a></li>
                  <li><a href="#relationship-queries">加载相关条目</a></li>
                  <li class="nav-label"><a href="#fieldtypes">域类型</a></li>
                  <li><a href="#fieldtypes-boolean">Boolean</a></li>
                  <li><a href="#fieldtypes-text">Text</a></li>
                  <li><a href="#fieldtypes-textarea">Textarea</a></li>
                  <li><a href="#fieldtypes-email">Email</a></li>
                  <li><a href="#fieldtypes-url">Url</a></li>
                  <li><a href="#fieldtypes-html">Html</a></li>
                  <li><a href="#fieldtypes-color">Color</a></li>
                  <li><a href="#fieldtypes-date">Date</a></li>
                  <li><a href="#fieldtypes-datetime">Datetime</a></li>
                  <li><a href="#fieldtypes-key">Key</a></li>
                  <li><a href="#fieldtypes-number">Number</a></li>
                  <li><a href="#fieldtypes-money">Money</a></li>
                  <li><a href="#fieldtypes-select">Select</a></li>
                  <li><a href="#fieldtypes-markdown">Markdown</a></li>
                  <li><a href="#fieldtypes-name">Name</a></li>
                  <li><a href="#fieldtypes-password">Password</a></li>
                  <li><a href="#fieldtypes-location">Location</a></li>
                  <li><a href="#fieldtypes-cloudinaryimage">CloudinaryImage</a></li>
                  <li><a href="#fieldtypes-cloudinaryimages">CloudinaryImages</a></li>
                  <li><a href="#fieldtypes-localfile">LocalFile</a></li>
                  <li><a href="#fieldtypes-s3file">S3 File</a></li>
                  <li><a href="#fieldtypes-azurefile">AzureFile</a></li>
                  <li><a href="#fieldtypes-embedly">Embedly</a></li>
                </ul>
              </ul>
            </nav>
          </div>
          <div class="col-sm-9">
            <div class="docs-content">
              <h2><a name="concepts"></a>概念</h2>
              <div class="alert alert-warning">
                <p>KeystoneJS 需要 MongoDB v2.4 或更高版本。</p>
              </div>
              <p>在KeystoneJS中，数据模式和模型是由<strong>列表</strong>控制的，并且数据库中的文档经常被称为<strong>条目</strong>。</p>
              <p>要定义数据模型，你要创建一个<code>new keystone.List</code>，然后传给它<a href="#lists-options">列表参数</a>。</p>
              <p>然后向列表中<code>add</code>域。在底层，Keystone List会创建一个<a href="https://mongoosejs.com/docs/guide.html" target="_blank">mongoose模式</a>，并为你添加的域给它定义恰当的路径。</p>
              <p>你可以访问<code>schema</code>，插入其它mongoose功能，比如虚拟域、方法和前置/后置钩子。</p>
              <p>完成列表的设置后，调用<code>list.register()</code>初始化它，并用Keystone注册。</p>
              <p>查询数据用<code>list.model</code> (这是一个<a href="https://mongoosejs.com/docs/models.html" target="_blank">mongoose 模型</a>)。</p>
              <p>列表条目是<a href="https://mongoosejs.com/docs/documents.html" target"_blank">mongoose 文档</a>。用<code>new list.model()</code>创建新条目，当准备好保存它时(或者将修改保存到已有条目上)调用<code>item.save()</code>。</p><a name="lists"></a>
              <h2>列表</h2><a name="lists-usage"></a>
              <h3>用法</h3>
              <h4><code>new keystone.List(key[, options]);</code></h4>
              <p>创建<strong>Keystone列表的语法</strong>跟创建Mongoose模式的语法非常像，只是构造器不一样，它是<code class='default-value'>var MyList = new keystone.List(key, options)</code>。</p>
              <p>新列表创建好以后，可以用<code>MyList.add(fields)</code>添加域，域是一个包含键（域的路径）和值（域的类型或参数）的对象。</p>
              <p>域是由带有<code>type</code>属性的对象定义的，这个<code>type</code>必须是有效的域类型或基本的数据类型。你可以用对象语法为域指定额外的参数。常用的域参数和域类型特定的参数在域文档中有详细介绍。</p>
              <p>列表上的所有域和参数都设好之后，调用<code>MyList.register()</code>用Keystone注册列表，并最终确定它的配置。</p><a name="lists-example"></a>
              <h3>例子</h3>
              <p>一个用于博客的简单Post模型可能会像下面这个：</p>
              <div class="code-header">
                <h4>Post.js</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Types = keystone.Field.Types;
 
var Post = new keystone.List('Post', {
    autokey: { path: 'slug', from: 'title', unique: true },
    map: { name: 'title' },
    defaultSort: '-createdAt'
});
 
Post.add({
    title: { type: String, required: true },
    state: { type: Types.Select, options: 'draft, published, archived', default: 'draft' },
    author: { type: Types.Relationship, ref: 'User' },
    createdAt: { type: Date, default: Date.now },
    publishedAt: Date,
    image: { type: Types.CloudinaryImage },
    content: {
        brief: { type: Types.Html, wysiwyg: true, height: 150 },
        extended: { type: Types.Html, wysiwyg: true, height: 400 }
    }
});
 
Post.defaultColumns = 'title, state|20%, author, publishedAt|15%'
Post.register();</code></pre>
              <p class="note">这个例子使用了可选的<code>map</code>、<code>autokey</code>和<code>defaultSort</code>参数，描述见下文。</p>
              <p class="note">它还指定<code>title</code>、<code>state</code>、<code>author</code>和<code>publishedAt</code>作为管理界面中默认显示的列，state和publishedAt还给定了列宽度。</p>
              <p class="note"><code>author</code>域是<code>Post</code>跟<code>User</code>模型的关系，在<a href="/zh/guide#models_users">入门指南</a>中介绍过。</p><a name="lists-options"></a>
              <h3>参数</h3>
              <p>列表支持以下参数：</p>
              <table class="table">
                <col width="210">
                <col>
                <tr>
                  <td><code>label</code> <code class="data-type">String</code></td>
                  <td>列表在管理界面中用的标签。默认为<code class="default-value">key</code>的友善格式。 </td>
                </tr>
                <tr>
                  <td><code>path</code> <code class="data-type">String</code></td>
                  <td>列表在管理界面中的路径。默认为<code class="default-value">key</code>的缩略名格式。</td>
                </tr>
                <t>
                  <td><code>singular</code> <code class="data-type">String</code></td>
                  <td>列表中条目的单数标签。用在管理界面中，默认为<code class="default-value">label</code>的单数格式。</td>
                </t>
                <tr>
                  <td><code>plural</code> <code class="data-type">String</code></td>
                  <td>列表中条目的复数标签。用在管理界面中，默认为<code class="default-value">label</code>的复数格式。</td>
                </tr>
                <tr>
                  <td><code>schema</code> <code class="data-type">String</code></td>
                  <td>
                    <p>列表的Mongoose模式的参数。 除了其他方面外，这个参数可以给<strong>集合</strong>指定一个定制的名称。参见<a href="https://mongoosejs.com/docs/guide.html#options" target="_blank">mongoose模式的文档</a>查看可用参数的清单。</p>
                    <p><em>警告: 不要修改模式参数<code>id</code>或<code>_id</code>；这是Keystone要求的默认行为。</em></p>
                  </td>
                </tr>
                <tr>
                  <td><code>drilldown</code> <code class="data-type">String</code></td>
                  <td>以空格分隔的关系清单，在管理界面中显示为下钻项。</td>
                </tr>
                <tr>
                  <td><code>sortable</code> <code class="data-type">Boolean</code></td>
                  <td>给模式添加一个隐藏的<code>sortOrder</code>域，并在管理界面中启用拖拽式的排序。</td>
                </tr>
                <tr>
                  <td><code>sortContext</code> <code class="data-type">String</code></td>
                  <td>管理界面中有拖拽式排序时用来控制的<code>List:relationship</code>对。</td>
                </tr>
                <tr>
                  <td><code>searchFields</code> <code class="data-type">String</code></td>
                  <td>在管理界面中用于搜索的路径清单，用空格分隔。</td>
                </tr>
                <tr>
                  <td><code>defaultSort</code> <code class="data-type">String</code></td>
                  <td>管理界面中用于排序的默认列或路径。</td>
                </tr>
                <tr>
                  <td><code>defaultColumns</code> <code class="data-type">String</code></td>
                  <td>
                    在管理界面的列表视图中默认显示的列清单，用逗号分隔。
                     你可以在管道符<code>|</code>后面用像素或百分比指定宽度。
                  </td>
                </tr>
                <tr>
                  <td><code>map</code> <code class="data-type">Object</code></td>
                  <td>将域映射到特定<strong>列表</strong>路径上的对象。如果添加了带那个键的域，则每个路径都默认为它的键。映射路径包括
                    <ul class="options">
                      <li><code>name</code> - 包含条目名称的域，显示在管理界面中</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <td><code>autokey</code> <code class="data-type">Object</code></td>
                  <td>在列表上添加一个插件，文档保存时自动基于另一个域或路径为它生成一个键。这个参数的值应该是带有如下键的对象：
                    <ul class="options">
                      <li><code>from</code> <code class="data-type">String</code> - 用于生成键值的域或路径，可以是用空格分开的域清单</li>
                      <li><code>path</code> <code class="data-type">String</code> - 存储键的路径</li>
                      <li><code>unique</code> <code class="data-type">Boolean</code> - 键是否应该有唯一性</li>
                      <li><code>fixed</code> <code class="data-type">Boolean</code> - 如果键存在并且非空，应该保留。默认为<code class="data-type">false</code>。</li>
                    </ul><em>路径Autokey是自动索引的；你可能还想把它放在复合索引中。</em>
                  </td>
                </tr>
                <tr>
                  <td><code>track</code> <code class="data-type">Boolean or Object</code></td>
                  <td> 
                    <p>在列表上添加一个插件，追踪谁在什么时候（比如哪个Keystone用户）创建和最后修改了一个条目。</p>
                    <p>设为<code class="data-type">true</code>时，所有追踪域都是用它们的默认名称启用的。 </p>
                    <p>你也可以选择性地启用各个域，并且还可以通过将<code>track</code>设为一个带有下面任一或全部域的<code class="data-type">object</code>来指定一个定制的域名：</p>
                    <ul class="options">
                      <li><code>createdAt</code> <code class="data-type">Boolean/String</code> - 设为<code class="data-type">true</code>时，追踪条目何时创建(使用默认的域名<em>createdAt</em>)。要使用定制的域名，用想要的名称设置<code class="data-type">String</code>。默认为<code class="data-type">false</code>。</li>
                      <li><code>createdBy</code> <code class="data-type">Boolean/String</code> -设为<code class="data-type">true</code>时，追踪哪个用户创建了条目(使用默认的域名<em>createdBy</em>)。要使用定制的域名，用想要的名称设置<code class="data-type">String</code>。默认为<code class="data-type">false</code>。</li>
                      <li><code>updatedAt</code> <code class="data-type">Boolean/String</code> - 设为<code class="data-type">true</code>时，追踪条目的最后更新时间(使用默认的域名<em>updatedAt</em>)。要使用定制的域名，用想要的名称设置<code class="data-type">String</code>。默认为<code class="data-type">false</code>。</li>
                      <li><code>updatedBy</code> <code class="data-type">Boolean/String</code> - 设为<code class="data-type">true</code>时，追踪是哪个用户最后更新了条目(使用默认的域名<em>updatedBy</em>)。要使用定制的域名，用想要的名称设置<code class="data-type">String</code>。默认为<code class="data-type">false</code>。</li>
                    </ul>
                    <p class="note"><code>createdBy</code>和<code>updatedBy</code>域只有通过Keystone管理界面添加/修改条目时才能自动更新。然而，如果你想在自己的程序内添加/修改条目，则必须在保存条目之前手工将条目的<code>._req_user</code>属性设为当前登录的用户(<code>req.user</code>)，如下例所示。</p>
                    <pre><code class="language-javascript">var item = new List.model();
item.set({ field1: 'value1', field2: 'value2' });
item._req_user = req.user;
item.save();</code></pre>
                  </td>
                </tr>
                <tr>
                  <td><code>noedit</code> <code class="data-type">Boolean</code></td>
                  <td>禁止在Keystone管理界面中编辑列表中的条目。</td>
                </tr>
                <tr>
                  <td><code>nocreate</code> <code class="data-type">Boolean</code></td>
                  <td>禁止在Keystone管理界面中创建列表的新条目。</td>
                </tr>
                <tr>
                  <td><code>nodelete</code> <code class="data-type">Boolean</code></td>
                  <td>禁止在Keystone管理界面中删除列表中的条目。</td>
                </tr>
                <tr>
                  <td><code>hidden</code> <code class="data-type">Boolean</code></td>
                  <td>在Keystone管理界面中隐藏这个列表。</td>
                </tr>
              </table>
              <p class="note">如果你想知道如何控制被分类列表在管理界面中的导航区域，请查看<a href="/zh/docs/configuration/#options-project">KeystoneJS配置</a>文档中的<code>nav</code>参数。</p>
              <h4>下钻示例</h4>
              <p>下钻参数是提高管理界面可用性的好办法，为用户当前正在编辑的条目提供上下文。</p>
              <p>默认情况下，下钻只会显示该条目所属的列表。</p>
              <p>然而你可以将它设为模式中的<code>Relationship</code>域，它就会显示当前存储在那个关系域中的条目。</p>
              <p>如果有几个要在下钻清单中显示的相关关系，可以用空格把它们分开。</p>
              <div class="code-header">
                <h4>例子：在帖子的下钻中包含作者</h4>
              </div>
              <pre><code class="language-javascript">var Post = new keystone.List('Post', {
    autokey: { path: 'slug', from: 'title', unique: true },
    map: { name: 'title' },
    defaultSort: '-createdAt',
    drilldown: 'author' // 在上面的例子中，author被定义为一个Relationship域
});</code></pre><a name="lists-plugins"></a>
              <h3>模式插件</h3>
              <p>你可以用<code>schema</code>指定<strong>列表</strong>的<a href="https://mongoosejs.com/docs/guide.html" target="_blank"><strong>虚拟域</strong>、<strong>方法</strong>、<strong>静态域</strong></a>和<a href="https://mongoosejs.com/docs/middleware.html" target="_blank"><strong>前置</strong>和<strong>后置</strong>钩子</a>。你也可以用<a href="https://plugins.mongoosejs.com" target="_blank">插件网站</a>上的<a href="https://mongoosejs.com/docs/plugins.html" target="_blank">mongoose插件</a>。</p>
              <p>比如说，在上面的<strong>Post</strong>列表中，我们可能想在<code>state</code>被改成<code>published</code>后自动设定<code>publishedAt</code>的值(但仅在它还没被设定过时)。</p>
              <p>我们可能还想添加个方法用来检查Post是否发布了，而不是直接检查<code>state</code>域的值。</p>
              <p>在调用<code>Post.register()</code>之前，我们先加上下面这段代码：</p>
              <pre><code class="language-javascript">Post.schema.methods.isPublished = function() {
    return this.state == 'published';
}
 
Post.schema.pre('save', function(next) {
    if (this.isModified('state') &amp;&amp; this.isPublished() &amp;&amp; !this.publishedAt) {
        this.publishedAt = new Date();
    }
    next();
});</code></pre><a name="lists-querying"></a>
              <h3>查询数据</h3>
              <p>要查询数据，你可以在<code>list.model</code>上使用任何<a href="https://mongoosejs.com/docs/queries.html" target="_blank">mongoose查询</a>方法。</p>
              <p><strong>比如说：</strong>要加载最新5条状态为<code>published</code>的<code>posts</code>，并组装可链接的<code>author</code>，按发布日期的降序排列：</p>
              <div class="code-header">
                <h4>加载Posts</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
Post.model.find()
    .where('state', 'published')
    .populate('author')
    .sort('-publishedAt')
    .limit(5)
    .exec(function(err, posts) {
        // 对帖子做些处理
    });</code></pre>
              <p><strong>Promises</strong></p>
              <p>还有一种处理mongoose查询中的事件的方法。除了传给<a href="https://mongoosejs.com/docs/api.html#query_Query-exec" target="_blank">exec</a>方法一个<a href="https://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/" target="_blank">回调函数</a>，我们还可以用它的返回结果：<a href="https://www.html5rocks.com/en/tutorials/es6/promises/" target="_blank">Promise</a>。对于带有错误传播的整洁事件链，Promise非常实用。</p>
              <p><strong>比如说：</strong>加载100条 <code>posts</code>，然后异步做些处理，然后再对其结果做些处理：</p>
              <div class="code-header">
                <h4>加载Posts，异步做些处理，然后再做些处理：</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
Post.model.find()
    .limit(100)
    .exec()
    .then(function (posts) { //第一个promise得到满足
        //返回另一个异步promise
    }, function (err) { //第一个promise被驳回
        throw err;
    }).then(function (result) { //第二个promise得到满足
        //对最终结果做些处理
    }, function (err) { //除了某些问题
        //捕获错误，它可能是链中的任何promise抛出的
        console.log(err);
    });</code></pre><a name="lists-paginate"></a>
              <h3>分页查询</h3>
              <p>你可以用<code>List.paginate()</code>进行分页查询，它会像<code>List.model.find()</code>一样返回一个查询对象，该方法支持下面这些参数：</p>
              <ul>
                <li><code>page</code> - 从哪一页开始</li>
                <li><code>perPage</code> - 每页的记录条数</li>
                <li><code>maxPages</code> - 可选参数，在计算页面时从开始/中间/末尾处省略页数（如果你有很多页，并且不想让它们显示时占好几行，就可以用这个参数）。</li>
              </ul>
              <p><strong>比如说：</strong> 要以<code>maxPages</code> 10 和<code>perPage</code> 10加载<code>posts</code>，并且要求其状态为<code>published</code>，同时组装出关联的<code>author</code>和<code>categories</code>，按发布时间的逆序排列：</p>
              <div class="code-header">
                <h4>分页加载Post</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
 Post.paginate({
		page: req.query.page || 1,
		perPage: 10,
		maxPages: 10
	})
	.where('state', 'published')
	.sort('-publishedDate')
	.populate('author categories')
	.exec(function(err, results) {
		locals.data.posts = results;
		next(err);
	});</code></pre>
              <p>当你在分页查询上调用<code>exec</code>时，除了查询结果，它还会返回很多元数据：</p>
              <ul>
                <li><code>total</code>: 匹配结果的总数(不仅仅是这一页的)</li>
                <li><code>results</code>: 这一页的结果集数组</li>
                <li><code>currentPage</code>: 当前页的页码</li>
                <li><code>totalPages</code>: 总页数</li>
                <li><code>pages</code>: 要显示的页码的数组</li>
                <li><code>previous</code>: 前一页的页码，如果当前页是第一页则为false</li>
                <li><code>next</code>: 下一页的页码，如果当前页是最后一页则为false</li>
                <li><code>first</code>: 包含第一条结果的页码</li>
                <li><code>last</code>: 包含最后一条结果的页码</li>
              </ul><a name="lists-creating"></a>
              <h3>创建条目</h3>
              <p>要创建新条目，还是用<a href="https://mongoosejs.com/docs/models.html" target"_blank">mongoose模型</a>：</p>
              <div class="code-header">
                <h4>创建Post</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
var newPost = new Post.model({
    title: 'New Post'
});
 
if (shouldBePublished) {
    newPost.state = 'published';
}
 
newPost.save(function(err) {
    // post已保存	
});</code></pre>
              <div class="contextual-note">
                <h4>自动键</h4>
                <p>因为我们在<code>Post</code>列表中设定了<code>autokey</code>参数，它会在post被保存到数据库中之前基于<code>title</code>生成一个唯一的键。</p>
                <pre>newPost.slug == 'new-post';</pre>
              </div><a name="lists-deleting"></a>
              <h3>删除条目</h3>
              <p>要删除条目，首先加载那项数据，然后用它的<code>remove</code>方法：</p>
              <div class="code-header">
                <h4>删除一个Post</h4>
              </div>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
Post.model.findById(postId)
    .remove(function(err) {
        // post已删除
    });</code></pre>
              <!-- TODO: Documentation for Schema features (virtuals, methods, statics and hooks)-->
              <!-- TODO: Documentation for Update Handler--><a name="headings"></a>
              <h2>标题</h2>
              <p>定义标题以区分文档流程。标题可以定义为 <code>String</code> 或者 <code>Object</code> 以及 <a href="#dependsOn">依赖于</a> 其他域的值。</p>
              <pre><code class="language-javascript">Person.add(
   'User', 
   { name: { type: Types.Name, required: true, index: true, initial: true } }, 
   'Permissions', 
   { isAdmin: { type: Boolean, label: 'Can access Keystone', index: true } },
   // header object
   { heading: 'Activities' }, 
   { place: { type: Types.Select, options: ['GT', 'UGA'] } },
   // header with dependsOn
   { heading: "GT Activities", dependsOn: { place: 'GT' } },
   { type: { type: Types.Select, options: ['ZC', 'MP'], dependsOn: { place: 'GT'} }
);</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>heading</code> <code class="data-type">String</code> -  标题显示的文字</p>
                <p><code>dependsOn</code> <code class="data-type">Object</code> - 标题只会在当前对象指定路径和数据项匹配时候显示。 <a href="#dependsOn">dependsOn</a> </p>
              </div><a name="fields"></a>
              <h2>域</h2>
              <p>在向<strong>列表</strong>中添加<strong>域</strong>时，你既可以指定基本数据类型，也可以用Keystone域类型。</p><a name="fields-overview"></a>
              <h3>概述</h3>
              <p>你可以用<strong>Keystone域</strong>轻松地向程序的模型中添加丰富的、功能化的域。它们不仅可以描述数据的<em>结构</em>，还可以描述数据的<em>意图</em>。它们提供了：</p>
              <ul>
                <li>Keystone管理界面中的丰富控件</li>
                <li>复杂的数据类型；比如存储几个字符串和GeoJSON经纬度的<code>location</code>域</li>
                <li>格式化和验证方法</li>
                <li>额外的虚拟属性；比如<code>name</code>提供了一个虚拟的<code>name.full</code>，将实际存储的<code>name.first</code>和<code>name.last</code>合并起来。</li>
                <li>Underscore方法；比如<code>password</code>域提供了一个<code>password.compare</code>方法， 用于比较加密的哈希值</li>
                <li>域之间彼此关系如何的元数据；比如哪个域依赖于其它域中的某个值</li>
              </ul>
              <p>基本数据类型跟Keystone的域类型是一一对应的：</p>
              <table style="width:200px" class="table">
                <col>
                <col>
                <thead>
                  <th>数据类型</th>
                  <th>域类型</th>
                </thead>
                <tr>
                  <td><code class="data-type">String</code></td>
                  <td><code class="data-type">Text</code></td>
                </tr>
                <tr>
                  <td><code class="data-type">Number</code></td>
                  <td><code class="data-type">Number</code></td>
                </tr>
                <tr>
                  <td><code class="data-type">Date</code></td>
                  <td><code class="data-type">DateTime</code></td>
                </tr>
                <tr>
                  <td><code class="data-type">Boolean</code></td>
                  <td><code class="data-type">Boolean</code></td>
                </tr>
              </table><a name="fields-options"></a>
              <h3>域参数</h3>
              <p>所有域类型都支持几个通用的参数，可以指定数据库设置(比如<code>index</code>和<code>default</code>)，或者为Keystone的管理界面提供信息(比如 <code>label</code>)。</p>
              <p class="note">域在对象内部可以嵌入，就像在mongoose模式中一样。</p>
              <p class="note">所有的<a href="https://mongoosejs.com/docs/schematypes.html" target="_blank">mongoose模式类型参数</a> 都是传给<a href="https://mongoosejs.com/docs/guide.html" target="_blank">mongoose模式</a>的，所以你也可以用mongoose支持的任何参数。</p>
              <p>常用的域参数有：</p>
              <table class="table">
                <col width="210">
                <col>
                <tr>
                  <td><code>label</code> <code class="data-type">String</code></td>
                  <td>每个域的标签都是由域路径生成的；设置这个参数会覆盖默认值。</td>
                </tr>
                <tr>
                  <td><code>required</code> <code class="data-type">Boolean</code></td>
                  <td>在条目保存前验证这个域是有值的(<em>还会传给mongoose并强制使用数据库索引</em>)。</td>
                </tr>
                <tr>
                  <td><code>initial</code> <code class="data-type">Boolean</code></td>
                  <td>让这个域出现在管理界面中的<strong>创建条目</strong>表单中。</td>
                </tr>
                <tr>
                  <td><code>noedit</code> <code class="data-type">Boolean</code></td>
                  <td>在管理界面中将这个域渲染为只读域。</td>
                </tr>
                <tr>
                  <td><code>note</code> <code class="data-type">String</code></td>
                  <td>在管理界面中跟着域显示。</td>
                </tr>
                <tr>
                  <td><code>hidden</code> <code class="data-type">Boolean</code></td>
                  <td>如果设为<code class="default-value">true</code>，则该域在管理界面中一直是隐藏域。</td>
                </tr>
              </table>
              <h3>条件域</h3>
              <p>为了提高管理界面的可用性，可以在某些域没有值时隐藏它们，或者根据其它域的取值隐藏。</p>
              <table class="table">
                <col width="210">
                <col>
                <tr>
                  <td><code>collapse</code> <code class="data-type">Boolean</code></td>
                  <td>该域没有值时在管理界面中显示一个<strong>+ <u>添加</u></strong>链接。当<code>noedit</code>也被设为<code class="default-value">true</code>时，该域没值时则完全隐藏。</td>
                </tr>
                <tr>
                  <td><code>dependsOn</code> <code class="data-type">Object</code></td>
                  <td>
                    <p>只有对象中指定的路径跟条目的当前数据匹配时才会显示
                      <p>你可以在每个路径上用数组对准多个值。</p>
                      <div class="code-header">
                        <h4>示例</h4>
                      </div>
                      <pre><code class="language-javascript">first: { type: String },
// 如果first === "value1", "1" 或 "2" 时将会显示
second: { type: String, dependsOn: { first: ['value1', '1', 2] } },
// 如果 first == "value1" 时会显示
third: { type: String, dependsOn: { first: 'value1' } }</code></pre>
                    </p>
                  </td>
                </tr>
              </table>
              <h3>生成的值及观测域</h3>
              <p>Keystone的域可以用简单的语法配置动态更新的域。你可以将一个域设置为在下面这些情况下更新它的值：</p>
              <ul>
                <li>条目保存时</li>
                <li>任何其它域的值发生变化时</li>
                <li>任何其它域的值变成特定值时</li>
              </ul>
              <p>要使用观测功能，设置下面两个参数：</p>
              <table class="table">
                <col width="210">
                <col>
                <tr>
                  <td><code>watch</code> <code class="data-type">Boolean</code>或<code class="data-type">String</code> 或<code class="data-type">Object</code>或<code class="data-type">Function</code></td>
                  <td>
                    <p>为<code class="default-value">true</code>时，每次保存条目都会重新计算这个域的值。 <br></p>
                    <p>提供一个用空格分隔的路径清单，其中任何一个发生变化时就重新计算这个域的值。 <br><strong>比如：</strong> <code class="default-value">'author title state'</code></p>
                    <p>提供一个键/值对的对象，其中任何一个路径变成指定的值时就重新计算这个域的值。<br><strong>比如：</strong> <code class="default-value">{'state': 'published', 'mainPost': true}</code></p>
                    <p>提供一个可以在需要时返回true/false的函数。<br><strong>比如：</strong> <code class="default-value">function() { return this.author === this.editor; }</code></p>
                  </td>
                </tr>
                <tr>
                  <td><code>value</code> <code class="data-type">Function</code></td>
                  <td>
                    <p>当所观测的路径发生变化时生成这个域的值的函数。必须返回新的值。</p>
                    <p>这个函数的<code>this</code>上下文是被保存的那个条目。</p>
                    <p><strong>比如：</strong></p>
                    <pre><code class="language-javascript">function () {
    return this.total<=this.totalreceived ? true:false;
}</code></pre>
                  </td>
                </tr>
              </table><a name="fields-underscoremethods"></a>
              <h3>Underscore方法</h3>
              <p>有些域类型包含辅助的<strong>underscore方法</strong>，在条目的域路径前面放一个下划线。</p>
              <p><strong>比如</strong>: 像下面这样用上面那个Posts列表中的<code>createdAt</code> <code class="data-type">DateTime</code>域的underscore方法<code>format</code> </p>
              <pre><code class="language-javascript">var keystone = require('keystone'),
    Post = keystone.list('Post');
 
Post.model.findById(postId).exec(function(err, post) {
   console.log(post._.createdAt.format('Do MMMM YYYY')); // 2013年8月25号
});</code></pre><a name="relationships"></a>
              <h2>关系</h2>
              <p>Keystone加强了MongoDB在域中存储相关文档的ObjectID的能力 (或者在数组中很多的ObjectID)，支持Relationship域和模型中的定义。</p><a name="relationship-fields"></a>
              <h3>关系域</h3>
              <h4><code class="data-type">ObjectId</code>或<code class="data-type">Array</code> &mdash; 在管理界面中显示为带有自动提示功能的输入域</h4>
              <p>将对另一个模型的ObjectID引用存到一个ObjectID域或数组中创建一对多或多对多关系。</p>
              <p>用<code>ref</code>参数指定相关模型。对于多对多关系而言，将<code>many</code>参数设为<code class="default-value">true</code>。</p>
              <p>比如说，如果你想将<strong>Post</strong>模型链到一个<strong>Author</strong>和多个<strong>PostCategories</strong>上时，可以这样做：</p>
              <pre><code class="language-javascript">Post.add({
    author: { type: Types.Relationship, ref: 'User' },
    categories: { type: Types.Relationship, ref: 'PostCategory', many: true }
});</code></pre>
              <h5>关系过滤器</h5>
              <p>你可以用<code>filters</code>参数过滤关系域。</p>
              <p><code>filters</code>参数是一个键/值对对象，其中键对应要过滤的相关模型的域，其中的值或者是字面值，或者是当前模型的域名，值会用来过滤关系。</p>
              <p>在下面的例子中，<code>author</code>域只允许选择<code>group</code>域等于'admin'的<code>User</code>。</p>
              <pre><code class="language-javascript">Post.add({
    title: { type: String, required: true },
    category: { type: Types.Select, options: 'user, editor, admin', default: 'user' },
    author: { type: Types.Relationship, ref: 'User', filters: { group: 'admin' } }
});</code></pre>
              <p>你也可以用模型中其它域的值过滤。将过滤器的值设为那个域的名称，前面加上分号(:)。</p>
              <p>在下例中，<code>author</code>域只能选择<code>group</code>域跟<code>Post</code>模型的<code>category</code>域的值相等的<code>User</code>。</p>
              <pre><code class="language-javascript">Post.add({
    title: { type: String, required: true },
    category: { type: Types.Select, options: 'user, editor, admin', default: 'user' },
    author: { type: Types.Relationship, ref: 'User', filters: { group: ':category' } }
});</code></pre>
              <p>最后，你还可以用当前模型的<code>_id</code>域过滤。</p>
              <p>在下例中，<code>bestPost</code>域只能选择<code>author</code>域等于当前文档的<code>_id</code>的<code>Post</code> 。</p>
              <pre><code class="language-javascript">User.add({
    name: { type: String, required: true },
    group: { type: Types.Select, options: 'user, editor, admin', default: 'user' },
    bestPost: { type: Types.Relationship, ref: 'Post', filters: { author: ':_id' } }
});</code></pre>
              <p class="note">你只能在一对多关系(即当<code>many</code>参数不为<code class="default-value">true</code>时)中设置过滤器。</p>
              <h5>在查询中组装相关数据</h5>
              <p>感谢<a href="https://mongoosejs.com/docs/populate.html" target="_blank">Mongoose的组装功能</a>，你可以为关系域组装相关数据。想在加载上面例子中的Post时组装author和category文档，应该这样做：</p>
              <pre><code class="language-javascript">Post.model.findOne().populate('author categories').exec(function(err, post) {
    // author是组装完整的User文档
    console.log(post.author.name);
});</code></pre>
              <p class="note">注意，如果没存ObjectId，或者保存的ObjectId无效(比如文档被删了)，上例中的<code>author</code>将变为<code class="data-type">undefined</code>。</p><a name="relationship-definitions"></a>
              <h3>关系定义</h3>
              <p>在上面的例子中，如果你想看到每位Author的Post清单该怎么做？因为关系域在Post上，你需要告诉Author（和PostCategory）模型它是被引用的。这样管理界面就可以从两个方向呈现这一关系。</p>
              <p>你可以像下面这样在<code>Model</code>上调用<code>relationship</code>：</p>
              <pre><code class="language-javascript">User.relationship({ path: 'posts', ref: 'Post', refPath: 'author' });</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>path</code> <code class="data-type">String</code> - 模型上的关系引用路径</p>
                <p><code>ref</code> <code class="data-type">String</code> - 引用方模型的键 (有关系域的那一方)</p>
                <p><code>refPath</code> <code class="data-type">String</code> - 引用方模型上的关系引用路径</p>
              </div>
              <p>如你所见，提供给<code>relationship</code>方法的这些参数是对关系域的镜像。</p>
              <p class="note">关系定义是可选的；如果你不定义，只是关系的另一侧不会在管理界面中显示这一关系。关系域仍能如期工作。</p><a name="relationship-queries"></a>
              <h3>加载相关条目</h3>
              <p>过滤一对多的相关条目很容易；只需要像其它任何值一样指定你希望过滤的条目的ID：</p>
              <pre><code class="language-javascript">Post.model.find().where('author', author.id).exec(function(err, posts) {
    // ...
});</code></pre>
              <p>要过滤多对多的相关条目，用条件<code>in</code>，并用数组指定一个(或多个)ID：</p>
              <pre><code class="language-javascript">Post.model.find().where('categories').in([category.id]).exec(function(err, posts) {
    // ...
});</code></pre><a name="fieldtypes"></a>
              <h2>域类型</h2><a name="fieldtypes-boolean"></a>
              <h3><code>Boolean</code></h3>
              <h4><code class="data-type">Boolean</code> &mdash; 在管理界面中显示为一个检查框</h4>
              <pre><code class="language-javascript">{ type: Types.Boolean }</code></pre><a name="fieldtypes-text"></a>
              <h3><code>Text</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本控件</h4>
              <pre><code class="language-javascript">{ type: Types.Text }</code></pre><a name="fieldtypes-textarea"></a>
              <h3><code>Textarea</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本框</h4>
              <pre><code class="language-javascript">{ type: Types.Textarea }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>height</code> <code class="data-type">Number</code> - 文本框的高度(以像素为单位)</p>
              </div><a name="fieldtypes-email"></a>
              <h3><code>Email</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本控件</h4>
              <p class="note">输入看起来必须像一个有效的email地址(如果不是必填项，可以为空)</p>
              <pre><code class="language-javascript">{ type: Types.Email, displayGravatar: true }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>displayGravatar</code> <code class="data-type">Boolean</code> - 是否在管理界面中显示gravatar图片</p>
                <h5>Underscore方法：</h5>
                <p><code>gravatarUrl(input, size, defaultImage, rating)</code> - 生成一个gravatar图片的请求url</p>
                <pre><code class="language-javascript">item.email = "demo@keystonejs.com";
item._.email.gravatarUrl(); // "//www.gravatar.com/avatar/74a0071e5f3a7107b570b7d4a1a7619d?s=80&d=identicon&r=g"
item._.email.gravatarUrl(200,'mm','r'); // "//www.gravatar.com/avatar/74a0071e5f3a7107b570b7d4a1a7619d?s=200&d=mm&r=r"</code></pre>
              </div><a name="fieldtypes-url"></a>
              <h3><code>Url</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本控件</h4>
              <pre><code class="language-javascript">{ type: Types.Url }</code></pre>
              <div class="options">
                <h5>Underscore方法：</h5>
                <p><code>format()</code> - 去掉存储的值前面的协议(如果有的话)</p>
                <pre><code class="language-javascript">item.url = "https://keystonejs.com";
item._.url.format(); // "keystonejs.com"</code></pre>
              </div><a name="fieldtypes-html"></a>
              <h3><code>Html</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本控件或WYSIWYG编辑器。</h4>
              <pre><code class="language-javascript">{ type: Types.Html, wysiwyg: true }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>wysiwyg</code> <code class="data-type">Boolean</code> - 在管理界面中是否显示WYSIWYG编辑器 - 要定制编辑器请参见<a href="/zh/docs/configuration/#options-ui">管理界面参数</a>。</p>
                <p><code>height</code> <code class="data-type">Number</code> - 输入域的高度(以像素为单位)</p>
              </div>
              <p>参见<a href="/zh/docs/configuration#options-ui">管理界面参数</a>了解用于定制WYSIWYG编辑器的全局配置参数。</p><a name="fieldtypes-color"></a>
              <h3><code>Color</code></h3>
              <h4><code class="data-type">Color</code> &mdash; 显示为带有取色器的文本控件</h4>
              <pre><code class="language-javascript">{ type: Types.Color }</code></pre><a name="fieldtypes-date"></a>
              <h3><code>Date</code></h3>
              <h4><code class="data-type">Date</code> &mdash; 在管理界面中显示为日期选择控件</h4>
              <p class="note">输入或者是有效的<strong>Date</strong>，或者是格式为<strong>YYYY-MM-DD</strong>的字符串 (除非为必填项，否则可以为空)</p>
              <p class="note">要将Date域设为当前时间，需将<code>default</code>参数设为<code class="default-value">Date.now</code></p>
              <pre><code class="language-javascript">{ type: Types.Date }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>format</code> <code class="data-type">string</code> - 默认的格式模式，默认为<code class="default-value">Do MMM YYYY</code></p>
                <p>参见<a href="https://momentjs.com/docs/#/displaying/format/" target="_blank">momentjs格式文档</a>了解所支持的格式和参数。</p>
                <h5>Underscore方法</h5>
                <p><code>format(string)</code> - 用<a href="https://momentjs.com" target="_blank">momentjs</a>格式化存储的值</p>
                <p><code>moment()</code> - 返回一个用该域的值初始化的<a href="https://momentjs.com" target="_blank">momentjs</a>对象</p>
                <p><code>parse(input, format, ...)</code> - 用<a href="https://momentjs.com" target="_blank">momentjs</a>解析input，将该域的值设为返回的moment对象</p>
                <p>参见<a href="https://momentjs.com/docs/#/parsing/" target="_blank">momentjs解析文档</a>了解所支持的格式和<code>parse</code>方法的参数。</p>
                <pre><code class="language-javascript">item.createdDate = Date.now();
item._.createdDate.format(); // 用默认的格式字符串返回当天的date
item._.createdDate.parse('2013-12-04'); // 用被解析的日期返回一个moment对象
item._.createdDate.format('YYYY-MM-DD'); // 返回'2013-12-04'</code></pre>
              </div><a name="fieldtypes-datetime"></a>
              <h3><code>Datetime</code></h3>
              <h4><code class="data-type">Datetime</code> &mdash; 在管理界面中显示为日期时间选择控件</h4>
              <p class="note">输入或者是有效的<strong>Date</strong>，或者是格式为<strong>YYYY-MM-DD</strong>的字符串 (除非为必填项，否则可以为空)</p>
              <p class="note">要将Date域设为当前时间，需将<code>default</code>参数设为<code class="default-value">Date.now</code></p>
              <pre><code class="language-javascript">{ type: Types.Datetime, default: Date.now }</code></pre>
              <div class="options">
                <h5>参数：</h5>
                <p><code>format</code> <code class="data-type">string</code> - 默认的格式模式，默认为<code class="default-value">Do MMM YYYY hh:mm:ss a</code></p>
                <p>参见<a href="https://momentjs.com/docs/#/displaying/format/" target="_blank">momentjs格式文档</a>了解所支持的格式和参数。</p>
                <h5>Underscore方法：</h5>
                <p><code>format(string)</code> -  用<a href="https://momentjs.com" target="_blank">momentjs</a>格式化存储的值</p>
                <p><code>moment()</code> - 返回一个用该域的值初始化的<a href="https://momentjs.com" target="_blank">momentjs</a>对象</p>
                <p><code>parse(input, format, ...)</code> - 用<a href="https://momentjs.com" target="_blank">momentjs</a>解析input，将该域的值设为返回的moment对象</p>
                <p>参见<a href="https://momentjs.com/docs/#/parsing/" target="_blank">momentjs解析文档</a>了解所支持的格式和<code>parse</code>方法的参数。</p>
              </div><a name="fieldtypes-key"></a>
              <h3><code>Key</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个文本输入域</h4>
              <p>自动将输入转为有效的键(没有空格或特殊字符)。用分隔符替换空格。</p>
              <pre><code class="language-javascript">{ type: Types.Key }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>separator</code> <code class="data-type">String</code> - 用来替换输入中空格的分隔符；默认为<code class="default-value">-</code></p>
              </div><a name="fieldtypes-number"></a>
              <h3><code>Number</code></h3>
              <h4><code class="data-type">Number</code> &mdash; 在管理界面中显示为一个数字输入控件</h4>
              <p>输入或者是有效的<strong>Number</strong>，或者是可以转换为数字的字符串(除非为必填项，否则可以为空)</p>
              <pre><code class="language-javascript">{ type: Types.Number }</code></pre>
              <div class="options">
                <h5>Underscore方法：</h5>
                <p><code>format(string)</code> - 用<a href="https://numeraljs.com" target="_blank">numeraljs</a>格式化存储的值。设为<code class="default-value">false</code>可以禁用自动格式化。</p>
                <p>格式化字符串默认为<code class="default-value">0,0[.][000000000000]</code></p>
              </div><a name="fieldtypes-money"></a>
              <h3><code>Money</code></h3>
              <h4><code class="data-type">Number</code> &mdash; 在管理界面中显示为一个数字输入控件</h4>
              <p>输入或者是有效的<strong>Number</strong>，或者是可以转换为数字的字符串(可以有前置符号；除非为必填项，否则可以为空)。金额控件不能识别币种。</p>
              <pre><code class="language-javascript">{ type: Types.Money }</code></pre>
              <div class="options">
                <h5>Underscore方法：</h5>
                <p><code>format(string)</code> - 用<a href="https://numeraljs.com" target="_blank">numeraljs</a>格式化存储的值。设为<code class="default-value">false</code>可以禁用自动格式化。</p>
                <p>格式化字符串默认为<code class="default-value">$0,0.00</code></p>
              </div><a name="fieldtypes-select"></a>
              <h3><code>Select</code></h3>
              <h4><code class="data-type">String</code>或<code class="data-type">Number</code> &mdash; 在管理界面中显示为选择输入控件</h4>
              <p class="note">类似于其他框架中的 <code>Enum</code>.</p>
              <pre><code class="language-javascript">{ type: Types.Select, options: 'first, second, third' }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>numeric</code> <code class="data-type">Boolean</code> 为<code class="default-value">true</code>时，会将该域的值存为<code class="data-type">Number</code>而不是<code class="data-type">String</code></p>
                <pre><code class="language-javascript">{ type: Types.Select, numeric: true, options: [{ value: 1, label: 'One' }, { value: 2, label: 'Two' }] }</code></pre>
                <p><code>emptyOption</code> <code class="data-type">Boolean</code> 为<code class="default-value">undefined || true</code>时，会添加一个空白的选择项<code>&lt;select&gt;</code>作为输入控件中的第一项</p>
                <pre><code class="language-javascript">{ type: Types.Select, required: true, options: 'first, second', emptyOption: false }</code></pre>
                <p><code>options</code> <code class="data-type">String</code>或<code class="data-type">Array</code> - 选择输入控件的选择项</p>
                <p>选择项的值可以是用逗号分隔的<code class="data-type">String</code>值列表，其中的字符串会被分割为<code class="data-type">Array</code>。</p>
                <p>对于选择项<code class="data-type">Array</code>，每个选择项或者是</p>
                <ul>
                  <li>表示选择项的<code>value</code>的<code class="data-type">String</code>；<code>label</code>是自动生成的</li>
                  <li>带有<code>value</code>和<code>label</code> <code class="data-type">String</code>属性的<code class="data-type">Object</code></li>
                </ul>
                <p>你可以在<code>options</code> <code class="data-type">Array</code>中混合<code class="data-type">String</code>和<code class="data-type">Object</code>条目：</p>
                <pre><code class="language-javascript">{ type: Types.Select, options: ['first', 'second', { value: 'third', label: 'The third one' }] }</code></pre>
                <p><code class="data-type">Object</code>选择项可以有额外的属性，可以在获取当前选择项的数据，或域参数时访问到。</p>
                <pre><code class="language-javascript">{ type: Types.Select, options: [
    { value: 'first', label: 'The first option', custom: 'value' },
    { value: 'second', label: 'Second' }
]}</code></pre>
                <h5>属性</h5>
                <p><code>ops</code> <code class="data-type">Array</code> - 输入控件的<strong>options</strong>数组</p>
                <p><code>values</code> <code class="data-type">Array</code> - 全部<code>option.value</code>属性</p>
                <p><code>labels</code> <code class="data-type">Object</code> - 全部<code>option.label</code>属性，以<code>option.value</code>为键</p>
                <p><code>map</code> <code class="data-type">Object</code> - options的映射，以<code>option.value</code>为键</p>
                <h5>模式</h5>
                <p>当前选择项的值会存在<code>{path}</code>上。此外还会提供这些虚拟域：</p>
                <p><code>pathLabel</code> <code class="data-type">String</code> - 当前选择的<strong>option</strong>的标签</p>
                <p><code>pathData</code> <code class="data-type">Object</code> - 当前选择的<strong>option</strong>，包含所有定制的属性</p>
                <p><code>pathOptions</code> <code class="data-type">Array</code> - 输入域的<strong>options</strong>数组</p>
                <p><code>pathOptionsMap</code> <code class="data-type">Object</code> - options的映射，以<code>option.value</code>为键</p>
                <h5>Underscore方法：</h5>
                <p><code>pluck(property, default)</code> - 返回当前选择的<strong>option</strong>的<code>property</code> 值，或者<code>default</code>。用于跟options的定制属性合并时。</p>
                <pre><code class="language-javascript">MyList.add({ state: { type: Types.Select, options: 'draft, published, archived', default: 'draft' });
 
MyList.fields.state.values == 'draft,published,archived';
MyList.fields.state.labels == { draft: 'Draft', published: 'Published', archived: 'Archived' };
MyList.fields.state.ops == [
    { value: 'draft', label: 'Draft' },
    { value: 'published', label: 'Published' },
    { value: 'archived', label: 'Archived' }
];
MyList.fields.state.map == {
    draft: { value: 'draft', label: 'Draft' },
    published: { value: 'published', label: 'Published' },
    archived: { value: 'archived', label: 'Archived' }
};
 
var item = new MyList.model();
item.state == 'draft';
item.stateLabel == 'Draft';
item.stateData == { value: 'draft', label: 'Draft' };
item.stateOptions == MyList.fields.state.ops;
item.stateOptionsMap == MyList.fields.state.map;</code></pre>
              </div><a name="fieldtypes-markdown"></a>
              <h3><code>Markdown</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一个文本框</h4>
              <pre><code class="language-javascript">{ type: Types.Markdown }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>height</code> <code class="data-type">Number</code> - 定义 markdown 编辑器高度；默认高度为 <code class="default-value">90</code>.</p>
                <pre><code class="language-javascript">{ type: Types.Markdown, height: 200 }</code></pre>
                <p><code>toolbarOptions</code> <code class="data-type">Object</code> - 可以定制工具栏。</p>
                <p><code>toolbarOptions.hiddenButtons</code> <code class="data-type">String</code> - 要隐藏的按钮清单，用逗号分隔。</p>
                <pre><code class="language-javascript">{ type: Types.Markdown, toolbarOptions: { hiddenButtons: 'H1,H6,Code' } }</code></pre>
                <h5>模式</h5>
                <p>当<code>md</code>属性发生变化时，markdown输入域会自动将markdown转换为html，这是通过<code>md</code>路径上的设定器完成的。</p>
                <p><code>md</code> <code class="data-type">String</code> - markdown源文本</p>
                <p><code>html</code> <code class="data-type">String</code> - 生成的html代码</p>
                <pre><code class="language-javascript">Page.add({ content: Types.Markdown });
 
var page = new Page.model();
page.content.md = "# Hello World";
page.content.html == "&lt;h1&gt;Hello World&lt;/h1&gt;";
 
// 或者...
 
Page.fields.content.updateItem(page, "* list item");
page.fields.content.format(page) == "&lt;ul&gt;&lt;li&gt;list item&lt;/ul&gt;&lt;/li&gt;";</code></pre>
              </div><a name="fieldtypes-name"></a>
              <h3><code>Name</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为<strong>firstname</strong> <strong>lastname</strong>输入控件</h4>
              <pre><code class="language-javascript">{ type: Types.Name }</code></pre>
              <div class="options">
                <h5>模式</h5>
                <p>name域在模式上添加了<code>first</code>和<code>last</code> <code class="data-type">String</code>路径，还有虚拟域<code>full</code>的getter和setter。</p>
                <p><code>first</code> <code class="data-type">String</code> - 姓氏</p>
                <p><code>last</code> <code class="data-type">String</code> - 名字</p>
                <h5>虚拟域</h5>
                <p><code>full</code> <code class="data-type">String</code> - 姓和名，中间加空格合并(如果两个都有值)。</p>
                <p><code>name.full</code> setter在第一个空格处分割输入值。</p>
              </div><a name="fieldtypes-password"></a>
              <h3><code>Password</code></h3>
              <h4><code class="data-type">String</code> &mdash; 在管理界面中显示为一个密码域，带有一个'修改'按钮。</h4>
              <p>密码是自动用bcrypt加密的，并且会输出一个方法用于把一个字符串跟加密的哈希值进行比较。</p>
              <p class="note">加密是添加在<strong>模式</strong>上的一个<strong>保存前钩子</strong>完成的，所以密码直到条目保存到数据库中时才会加密。</p>
              <pre><code class="language-javascript">{ type: Types.Password }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>workFactor</code> <code class="data-type">Number</code> - 生成哈希值时用的加密因子，数值越大越慢，但也更安全(默认为<code class="default-value">10</code>)</p>
                <h5>Underscore方法：</h5>
                <p><code>compare(candidate, callback)</code> - 对候选值加密，并跟已加密的哈希值进行比较</p>
                <ul>
                  <li><code>candidate</code> 要比较的<code class="data-type">String</code></li>
                  <li><code>callback(err, result)</code> - 如果候选值跟保存的密码相配，则<strong>result</strong>为<code class="default-value">true</code>，否则为<code class="default-value">false</code>。</li>
                </ul>
                <h5>特殊路径</h5>
                <p><code>{path}_compare</code> - 提供给<strong>updateHandler</strong>时，它会对照<code>{path}</code>进行检查，如果不匹配则验证会失败。</p>
              </div><a name="fieldtypes-location"></a>
              <h3><code>Location</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一组输入控件的组合</h4>
              <p>包含一组标准的字符串，用于存储地址，带有<code class="data-type">2dsphere</code>索引的经纬度。</p>
              <p>还用谷歌的Places API提供输入自动补充功能 (需要提供谷歌地图API键，并且只能用于相应的谷歌服务条款)。</p>
              <p>参见<a href="/zh/docs/configuration#services-google">谷歌配置文档</a>了解如何在KeystoneJS中设置谷歌地图的详细介绍。</p>
              <pre><code class="language-javascript">{ type: Types.Location }</code></pre>
              <p class="note">注意：模式的路径是基于澳大利亚的地址格式，并且应该更新为其它更加国际化的格式。如果你有如何进行国际化结构的反馈，请开一个工单。</p>
              <div class="options">
                <h5>模式</h5>
                <p><code>name</code> <code class="data-type">String</code> - 建筑的名称</p>
                <p><code>number</code> <code class="data-type">String</code> - 单位或店铺号</p>
                <p><code>street1</code> <code class="data-type">String</code> - 街道地址</p>
                <p><code>street2</code> <code class="data-type">String</code> - 街道地址第2行</p>
                <p><code>suburb</code> <code class="data-type">String</code></p>
                <p><code>state</code> <code class="data-type">String</code></p>
                <p><code>postcode</code> <code class="data-type">String</code></p>
                <p><code>country</code> <code class="data-type">String</code></p>
                <p><code>geo</code> <code class="data-type">Array</code> <code class="default-value">longitude, latitude</code></p>
                <p class="note"><strong>重要提示</strong>: 按照MongoDB的传统，<strong>geo</strong>数组的顺序必须是<code class="default-value">lng, lat</code>，跟谷歌API所用的顺序相反。</p>
                <h5>Underscore方法：</h5>
                <p><code>googleLookup(region, update, callback)</code> - 从存储的值中自动检测完整的地址和经纬度。</p>
                <ul>
                  <li><code>region</code> 为了进行区域性偏移和过滤而传给Places API的<code class="data-type">String</code>。</li>
                  <li><code>update</code> <code class="data-type">String</code>传给<code class="default-value">"overwrite"</code>会自动用结果覆盖已有数据。<code class="default-value">true</code>会在这个域上用结果设定空白属性。</li>
                  <li><code>callback(err, location, result)</code> - 传给解析过的<strong>location</strong>对象，以及来自谷歌的原始<strong>result</strong>。</li>
                </ul>
                <p>内部状态码模仿谷歌API的状态码。参见<a href="https://developers.google.com/maps/documentation/geocoding/" target="_blank">https://developers.google.com/maps/documentation/geocoding/</a>了解详情。</p>
                <p>使用谷歌Geocoding API要受到每天不超过2,500 geolocation请求的限制，除非有企业许可。</p>
                <p>Geocoding API只能用于谷歌地图；geocoding结果必须在地图上显示。请确保你的Keystone程序遵守谷歌地图API的许可。</p>
              </div><a name="fieldtypes-cloudinaryimage"></a>
              <h3><code>CloudinaryImage</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一个图片上传控件。</h4>
              <p>自动管理存在<a href="https://cloudinary.com" target="_blank">Cloudinary</a>中的图片，包括上传、缩放和删除。</p>
              <p>参见<a href="/zh/docs/configuration#services-cloudinary">Cloudinary配置文档</a>了解如何在KeystoneJS中设置Cloudinary的细节。</p>
              <pre><code class="language-javascript">{ type: Types.CloudinaryImage }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>publicID</code> <code class="data-type">String</code> 用作Cloudinary图片 <code class="data-type">public_id</code>域的名称。</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImage, publicID: 'slug' }</code></pre>
                <p><code>folder</code> <code class="data-type">String</code> 当<code class="default-value">cloudinary folders</code>设为<code class="default-value">true</code>时，用来为Cloudinary图片<code class="data-type">public_id</code>指定文件夹/前缀</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImage, folder: 'path/to/image' }</code></pre>
                <p class="note">如果你希望 Cloudinary 在 <code>cloudinary folders</code> 设置为 <code class="default-value">true</code>  的时候自动创建文件夹， 确认已经在你的 Cloudinary 账户中启用 "Auto-create folders"。</p>
                <p><code>autoCleanup</code> <code class="data-type">Boolean</code> 为<code class="default-value">true</code>时，会将Keystone的默认行为从<code class="default-value">remove</code> (只是从数据库中去掉Cloudinary 图片)变成<code class="default-value">delete</code> (会同时从数据库和Cloudinary存储中去掉图片)。此外，这个参数还会在上传时替换掉已有图片(如果图片已存在的话)。</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImage, autoCleanup : true }</code></pre>
                <p><code>select</code> <code class="data-type">Boolean</code> 为<code class="default-value">true</code> 时，会显示一个下拉列表域，其中是当前保存在Cloudinary存储中的图片。当指定<code>selectPrefix</code>时，只有ID以<code>selectPrefix</code>开头的图片才会显示。否则，显示ID以<code>folder</code>开头的图片。如果既没有配置<code>selectPrefix</code>，也没配置<code>folder</code>，则只显示ID以<code class="data-type">[{prefix}]/{list.path}/{field.path}/</code>开头的图片。</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImage, select : true }</code></pre>
                <p><code>selectPrefix</code> <code class="data-type">String</code> 当<code>select</code>参数为<code class="default-value">true</code>时指定可供选择的图片的前缀。</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImage, select: true, selectPrefix: 'path/to/images' }</code></pre>
                <h5>模式</h5>
                <p><code>public_id</code> <code class="data-type">String</code></p>
                <p><code>version</code> <code class="data-type">Number</code></p>
                <p><code>signature</code> <code class="data-type">String</code></p>
                <p><code>format</code> <code class="data-type">String</code></p>
                <p><code>resource_type</code> <code class="data-type">String</code></p>
                <p><code>url</code> <code class="data-type">String</code></p>
                <p><code>width</code> <code class="data-type">Number</code></p>
                <p><code>height</code> <code class="data-type">Number</code></p>
                <p><code>secure_url</code> <code class="data-type">String</code></p>
                <h5>虚拟域</h5><code>exists</code> <code class="data-type">Boolean</code> - 是否保存有图片
                <h5>特殊路径</h5>
                <p><code>{path}_upload</code> - 当给<strong>updateHandler</strong>提供了<code class="data-type">file</code>时，它会被上传到cloudinary，并且详细信息会存在该域中。</p>
                <h5>Underscore方法：</h5>
                <p><code>src(options)</code> <code class="data-type">String</code> - 返回图片的url，接受cloudinary支持的所有参数</p>
                <p><code>tag(options)</code> <code class="data-type">String</code> - 返回一个<code class="default-value">&lt;img&gt;</code>标签</p>
                <p><code>scale(width, height, options)</code> <code class="data-type">String</code> - 将图片缩放到恰当的宽度和高度，比例保持不变。</p>
                <p><code>fit(width, height, options)</code> <code class="data-type">String</code> - 在指定的宽度和高度内缩放图片，比例保持不变。</p>
                <p><code>lfit(width, height, options)</code> <code class="data-type">String</code> - 缩放图片以适应指定的宽度和高度，比例保持不变(不超出原始维度)</p>
                <p><code>limit(width, height, options)</code> <code class="data-type">String</code> - 缩放图片(仅向下)以适应指定的宽度和高度，比例保持不变</p>
                <p><code>fill(width, height, options)</code> <code class="data-type">String</code> - 缩放图片以填充指定的宽度和高度</p>
                <p><code>crop(width, height, options)</code> <code class="data-type">String</code> - 裁剪图片以填充指定的宽度和高度</p>
                <p><code>pad(width, height, options)</code> <code class="data-type">String</code> - 补白图片以填充指定的宽度和高度</p>
                <p><code>lpad(width, height, options)</code> <code class="data-type">String</code> - 补白图片以填充指定的宽度和高度(不超出原始维度)</p>
                <p><code>thumbnail(width, height, options)</code> <code class="data-type">String</code> - 裁剪图片以填充指定的宽度和高度</p>
                <p>所有方法中的<code class="default-value">options</code>都是可选的<code class="data-type">Object</code>。 参见<a href="https://cloudinary.com/documentation/image_transformations" target="_blank">Cloudinary的转换文档</a>了解所支持的参数和转换。 </p>
              </div>
              <p class="note">记住，如果用HTML表单上传图片到<code>CloudinaryImage</code>域，需要在<code>form</code>标签中指定<code>enctype="multipart/form-data"</code>。</p><a name="fieldtypes-cloudinaryimages"></a>
              <h3><code>CloudinaryImages</code></h3>
              <h4><code class="data-type">Array</code> &mdash; 在管理界面中显示为一系列图片，以及一个上传控件。</h4>
              <p>将数组中的多个图片存为嵌套的<code class="data-type">Schema</code>，每个都会输出跟<code class="data-type">cloudinaryimage</code>域一样的方法。</p>
              <pre><code class="language-javascript">{ type: Types.CloudinaryImages }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>folder</code> <code class="data-type">String</code> 当<code class="default-value">cloudinary folders</code>设为<code class="default-value">true</code>时，用来为Cloudinary图片<code class="data-type">public_id</code>指定文件夹/前缀。</p>
                <pre><code class="language-javascript">{ type: Types.CloudinaryImages, folder: 'path/to/image' }</code></pre>
                <p class="note">如果你希望 Cloudinary 在 <code>cloudinary folders</code> 设置为 <code class="default-value">true</code>  的时候自动创建文件夹， 确认已经在你的 Cloudinary 账户中启用 "Auto-create folders"。</p>
              </div><a name="fieldtypes-localfile"></a>
              <h3><code>LocalFile</code></h3>
              <div class="alert alert-warning">这个域类型跟Heroku之类的PAAS Hosts不兼容，因为它要依赖本地文件系统。</div>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一个文件上传控件。 </h4>
              <p>在本地文件系统中存放文件。</p>
              <pre><code class="language-javascript">{ type: Types.LocalFile }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>dest</code> <code class="data-type">String</code> - 必填项，存放上传文件的路径。</p>
                <p><code>prefix</code> <code class="data-type">String</code> - 浏览器中的路径前缀，如果跟<code>dest</code>不同的话</p>
                <p><code>datePrefix</code> <code class="data-type">String</code> - 如果设了，以这种格式的当前日期作为文件名的前缀(参见 <a href="https://momentjs.com" target="_blank">moment.js</a>了解格式参数)</p>
                <p><code>allowedTypes</code> 包含<code class="data-type">String</code>的<code class="data-type">Array</code>  - 可以上传的文件mime类型白名单</p>
                <p><code>filename</code> <code class="data-type">Function</code> - 以当前模型和客户端文件名为参数的函数，返回要上传文件的新文件名。</p>
                <p><code>format</code> <code class="data-type">Function</code> - 带两个参数的函数：当前模型和文件对象，返回这个文件在管理界面中的表示。
                  <pre><code class="language-javascript">{
	type: Types.LocalFile,
	dest: '/data/files',
	prefix: '/files/',
	format: function(item, file){
		return '&lt;img src="/files/'+file.filename+'" style="max-width: 300px"&gt;'
	}
}
</code></pre>
                </p>
                <h5>模式</h5>
                <p><code>filename</code> <code class="data-type">String</code></p>
                <p><code>path</code> <code class="data-type">String</code></p>
                <p><code>size</code> <code class="data-type">Number</code></p>
                <p><code>filetype</code> <code class="data-type">String</code></p>
                <h5>虚拟域</h5><code>exists</code> <code class="data-type">Boolean</code> - 是否保存了这样一个文件
                <h5>Underscore方法：</h5>
                <p><code>uploadFile(file, update, callback)</code> - 将文件上传到本地存储，在该域中保存文件细节信息，并将文件数据提供给回调函数。</p>
                <ul>
                  <li><code>file</code> <code class="data-type">File</code> 文件上传时应该是由express提供的文件，即<code class="default-value">req.files.path</code></li>
                  <li><code>update</code> <code class="data-type">Boolean</code> 文件上传完后是否用文件的细节信息更新该域。</li>
                  <li><code>callback(err, fileData)</code> - 传递将会存储在该域中的对象(见上面的模式)</li>
                </ul>
              </div><a name="fieldtypes-s3file"></a>
              <h3><code>S3 File</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一个文件上传控件。</h4>
              <p> 自动管理存在<a href="https://aws.amazon.com/s3" target="_blank">亚马逊S3</a>上的文件，包括上传和删除。</p>
              <pre><code class="language-javascript">{ type: Types.S3File }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>s3path</code> <code class="data-type">String</code> - 在S3的桶中存放上传文件的路径。</p>
                <p><code>datePrefix</code> <code class="data-type">String</code> - 如果设了，以这种格式的当前日期作为文件名的前缀(参见 <a href="https://momentjs.com" target="_blank">moment.js</a>了解格式参数)</p>
                <p><code>allowedTypes</code> 包含<code class="data-type">String</code>的<code class="data-type">Array</code>  - 可以上传的文件mime类型白名单</p>
                <p><code>filename</code> <code class="data-type">Function</code> - 以当前模型和客户端文件名为参数的函数，返回要上传文件的新文件名。
                  <pre><code class="language-javascript">{
	type: Types.S3File,
	filename: function(item, filename){
		// 用object id作为文件名的前缀
		return item._id + '-' + filename;
	}
}</code></pre>
                </p>
                <p><code>headers</code> <code class="data-type">Object</code>，<code class="data-type">Array</code> 或者 <code class="data-type">Function</code> - 设置 S3 对象请求头</p>
                <p>请求头可以提供 <code class="data-type">Object</code> 类型， 键值对的键被用来定义请求头名称，值用来设置请求头的值。
                  <pre><code class="language-javascript">{
	type: Types.S3File, 
		headers: {
		'x-amz-meta-Cache-Control' : 'max-age=' + (60 * 15),
		'x-amz-meta-X-Custom-Header' : 'Object Option'
	} 
}</code></pre>
                </p>
                <p>当用 <code class="data-type">Array</code> 设置请求头， 数组内的每一个请求头元素应该是一个 <code class="data-type">Object</code> 类型包含 <code>name</code>和 <code>value</code> <code class="data-type">String</code> 属性。
                  <pre><code class="language-javascript">{ 
	type: Types.S3File, 
		headers: [
		{ name: 'x-amz-meta-Cache-Control', value: 'max-age=' + (60 * 15) },
		{ name: 'x-amz-meta-X-Custom-Header', value: 'Array Option' }
	]
}</code></pre>
                </p>
                <p>当用 <code class="data-type">Function</code> 设置请求头，以当前模型和客户端文件名为参数的函数；该函数返回一个有效的请求头对象或者一个简单 <code class="data-type">Object</code> 类型对象。
                  <pre><code class="language-javascript">{ 
	type: Types.S3File, 
		headers: function (item, file){
		var headers = [];
		headers.push({ name: 'x-amz-meta-Cache-Control', value: 'max-age=' + item.maxAge });
		headers.push({ name: 'x-amz-meta-X-Custom-Header', value: 'Computed Option (Array)' });
		return headers;
	}
}
// 或 
{
	type: Types.S3File,
		headers: function (item, file){
		var headers = {};
		headers['x-amz-meta-Cache-Control'] = 'max-age=' + item.maxAge;
		headers['x-amz-meta-X-Custom-Header'] = 'Computed Option (Object)';
		return headers;
	}
}	</code></pre>
                </p>
                <p><code>format</code> <code class="data-type">Function</code> - 以当前模型和客户端文件名为参数的函数，返回要上传文件的新文件名。
                  <pre><code class="language-javascript">{
	type: Types.S3File,
	format: function(item, file){
		return '&lt;pre&gt;'+JSON.stringify(file, false, 2)+'&lt;/pre&gt;'+
					'&lt;img src="'+file.url+'" style="max-width: 300px"&gt;'
	}
}
</code></pre>
                </p>
                <h5>模式</h5>
                <p><code>filename</code> <code class="data-type">String</code></p>
                <p><code>type</code> <code class="data-type">String</code></p>
                <p><code>filesize</code> <code class="data-type">Number</code></p>
                <p><code>url</code> <code class="data-type">String</code></p>
                <h5>虚拟域</h5><code>exists</code> <code class="data-type">Boolean</code> - 是否保存了这样一个文件
                <h5>特殊路径</h5>
                <p><code>{path}_upload</code> - 当提供给<strong>updateHandler</strong>一个<code class="data-type">file</code>时，这个文件将会被上传到s3上，并且其细节信息会保存在该域中。</p>
                <h5>Underscore方法：</h5>
                <p><code>uploadFile(file, update, callback)</code> - 将文件上传到s3的桶中，在该域中保存文件细节信息，并将文件数据提供给回调函数。</p>
                <ul>
                  <li><code>file</code> <code class="data-type">File</code> 文件上传时应该是由express提供的文件，即<code class="default-value">req.files.path</code></li>
                  <li><code>update</code> <code class="data-type">Boolean</code> 文件上传完后是否用文件的细节信息更新该域。</li>
                  <li><code>callback(err, fileData)</code> - 传递将会存储在该域中的对象(见上面的模式)</li>
                </ul>
              </div><a name="fieldtypes-azurefile"></a>
              <h3><code>AzureFile</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为一个文件上传控件。</h4>
              <p>自动管理存在<a href="https://www.windowsazure.com/" target="_blank">Windows Azure Storage</a>中的文件，包括上传和删除。</p>
              <pre><code class="language-javascript">{ type: Types.AzureFile }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>filenameFormatter</code> <code class="data-type">Callback</code> - 以当前模型和客户端文件名为参数的函数，返回要上传文件的新文件名。</p>
                <pre><code class="language-javascript">{ type: Types.AzureFile, filenameFormatter: function(item, filename) {
	return item._id + require('path').extname(filename);
} }</code></pre>
                <p><code>containerFormatter</code> <code class="data-type">Callback</code> - 以当前模型和客户端文件名为参数的函数，返回新的容器名(容器是Azure存储账号中的根文件夹)。</p>
                <pre><code class="language-javascript">{ type: Types.AzureFile, containerFormatter: containerFormatter: function(item, filename) {
	return item.modelProperty;
} }</code></pre>
                <h5>模式</h5>
                <p><code>filename</code> <code class="data-type">String</code></p>
                <p><code>type</code> <code class="data-type">String</code></p>
                <p><code>filesize</code> <code class="data-type">Number</code></p>
                <p><code>url</code> <code class="data-type">String</code></p>
                <p><code>etag</code> <code class="data-type">String</code></p>
                <h5>虚拟域</h5><code>exists</code> <code class="data-type">Boolean</code> - 是否保存了这样一个文件
                <h5>Underscore方法：</h5>
                <p><code>uploadFile(file, update, callback)</code> - 将文件上传到Azure存储账号，在该域中保存文件细节信息，并将文件数据提供给回调函数。</p>
                <ul>
                  <li><code>file</code> <code class="data-type">File</code> 文件上传时应该是由express提供的文件，即<code class="default-value">req.files.path</code></li>
                  <li><code>update</code> <code class="data-type">Boolean</code> 文件上传完后是否用文件的细节信息更新该域。</li>
                  <li><code>callback(err, fileData)</code> - 传递将会存储在该域中的对象(见上面的模式)</li>
                </ul>
              </div><a name="fieldtypes-embedly"></a>
              <h3><code>Embedly</code></h3>
              <h4><code class="data-type">Object</code> &mdash; 在管理界面中显示为只读数据。</h4>
              <p>自动从<a href="https://embed.ly" target="_blank">Embedly</a> API获取跟另一个域的值相关的信息(由<code>from</code> 参数指定)。</p>
              <p>它存储获取的数据(包括提供者、媒体类型、完整的URL、HTML嵌入代码、宽度、高度、缩略图及更多信息)。</p>
              <p>获取数据的api调用是作为保存前置钩子实现的，并且只在<strong>from路径</strong>的值发生变化时才会触发。</p>
              <p>参见<a href="/zh/docs/configuration#services-embedly">Embed.ly配置文档</a>了解如何在KeystoneJS中设置Embed.ly的详细介绍。 </p>
              <pre><code class="language-javascript">{ type: Types.Embedly, from: 'path' }</code></pre>
              <div class="options">
                <h5>参数</h5>
                <p><code>from</code> <code class="data-type">String</code> - 模式中传给Embedly API的另一个域的路径。另一个域中必须包含一个<code class="data-type">String</code>值。</p>
                <p><code>options</code> <code class="data-type">Object</code> (optional) - 跟<code>from</code>域的值一起作为参数传给embedly API。</p>
                <p>参见<a href="https://embed.ly/docs/embed/api/endpoints/1/oembed" target="_blank">Embedly的oEmbed API 文档</a>了解参数及返回数据的更多信息。</p>
                <h5>模式</h5>
                <p><code>exists</code> <code class="data-type">Boolean</code></p>
                <p><code>type</code> <code class="data-type">String</code></p>
                <p><code>title</code> <code class="data-type">String</code></p>
                <p><code>url</code> <code class="data-type">String</code></p>
                <p><code>width</code> <code class="data-type">Number</code></p>
                <p><code>height</code> <code class="data-type">Number</code></p>
                <p><code>version</code> <code class="data-type">String</code></p>
                <p><code>description</code> <code class="data-type">String</code></p>
                <p><code>html</code> <code class="data-type">String</code></p>
                <p><code>authorName</code> <code class="data-type">String</code></p>
                <p><code>authorUrl</code> <code class="data-type">String</code></p>
                <p><code>providerName</code> <code class="data-type">String</code></p>
                <p><code>providerUrl</code> <code class="data-type">String</code></p>
                <p><code>thumbnailUrl</code> <code class="data-type">String</code></p>
                <p><code>thumbnailWidth</code> <code class="data-type">Number</code></p>
                <p><code>thumbnailHeight</code> <code class="data-type">Number</code></p>
              </div>
              <h2>更多范例</h2>
              <p>参见项目的<a href="/zh/examples">范例</a>页面，了解各种列表参数和域类型的真实用法。</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="docs-footer">
      <div class="container">
        <p>Created by <a href="https://twitter.com/jedwatson" target="_blank">@jedwatson</a>, <a href="https://twitter.com/bladey" target="_blank">@bladey</a> and <a href="https://twitter.com/jossmackison" target="_blank">@jossmackison</a> at <a href="https://www.thinkmill.com.au" target="_blank">Thinkmill</a>, and other <a href="https://github.com/keystonejs/keystone/contributors" target="_blank">contributors</a> under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a></p>
        <ul class="list-inline">
          <li><a href="/zh/getting-started" title="KeystoneJS Getting Started">Getting Started</a></li>
          <li><a href="/zh/docs" title="KeystoneJS Documentation">Documentation</a></li>
          <li><a href="https://groups.google.com/forum/#!forum/keystonejs" target="_blank" title="KeystoneJS Google Group">Google Group</a></li>
          <li><a href="https://github.com/keystonejs/keystone" target="_blank" title="Github Project (new window)">Github Project</a></li>
          <li><a href="https://demo.keystonejs.com" target="_blank" title="Demo Website (new window)">Demo Website</a></li>
          <li><a href="/zh/examples" title="KeystoneJS Database">Examples</a></li>
        </ul>
      </div>
    </div>
    <div class="docs-footer-floor">
      <div class="container">
        <div class="social-buttons">
          <div class="social-button social-button__twitter"><a href="https://twitter.com/keystonejs" data-show-count="true" class="twitter-follow-button">Follow @keystonejs</a></div>
          <div class="social-button social-button__github">
            <iframe src="https://ghbtns.com/github-btn.html?user=keystonejs&amp;repo=keystone&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="86" height="20"></iframe>
          </div>
        </div>
      </div>
    </div>
    <script src="/js/lib/jquery/jquery-1.10.2.min.js"></script>
    <script src="/js/lib/bootstrap/collapse.js"></script>
    <script src="/js/lib/prism/prism.min.js"></script>
    <script src="/js/anchor-links.js"></script>
    <script>
      !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
      
    </script>
    <script>
      if (window.location.hostname.match(/keystonejs\.com/)) {
      	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      	ga('create', 'UA-43970386-1', 'keystonejs.com');
      	ga('send', 'pageview');
      }
      
    </script>
    <script>
      if (window.location.hostname.match(/keystonejs\.com/)) {
      	var _sf_async_config = { uid: 46610, domain: 'keystonejs.com', useCanonical: true };
      	(function() {
      		function loadChartbeat() {
      			window._sf_endpt = (new Date()).getTime();
      			var e = document.createElement('script');
      			e.setAttribute('language', 'javascript');
      			e.setAttribute('type', 'text/javascript');
      			e.setAttribute('src','//static.chartbeat.com/js/chartbeat.js');
      			document.body.appendChild(e);
      		};
      		var oldonload = window.onload;
      		window.onload = (typeof window.onload != 'function') ?
      		loadChartbeat : function() { oldonload(); loadChartbeat(); };
      	})();
      }
      
    </script>
    <script>
      if (window.location.hostname.match(/keystonejs\.com/)) {
      	setTimeout(function(){var a=document.createElement("script");
      	var b=document.getElementsByTagName("script")[0];
      	a.src=document.location.protocol+"//dnn506yrbagrg.cloudfront.net/pages/scripts/0013/3329.js?"+Math.floor(new Date().getTime()/3600000);
      	a.async=true;a.type="text/javascript";b.parentNode.insertBefore(a,b)}, 1);
      }
    </script>
  </body>
</html>