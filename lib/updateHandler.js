var _ = require('lodash');
var keystone = require('../');
var async = require('async');
var evalDependsOn = require('../fields/utils/evalDependsOn.js');
var debug = require('debug')('keystone:lib:updateHandler');
/**
 * UpdateHandler Class
 *
 * @param {Object} item to update
 * @api public
 */

function UpdateHandler (list, item, req, res, options) {

	if (!(this instanceof UpdateHandler)) {
		return new UpdateHandler(list, item);
	}

	this.list = list;
	this.item = item;
	this.req = req;
	this.res = res;
	this.user = req.user;
	this.options = options || {};

	if (!this.options.errorMessage) {
		this.options.errorMessage = 'There was a problem saving your changes:';
	}

	if (this.options.user) {
		this.user = this.options.user;
	}

	this.validationMethods = {};
	this.validationErrors = {};

}


/**
 * Adds a custom validation method for a given path
 *
 * @param {string} path to call method for
 * @param {function} method to call
 * @api public
 */

UpdateHandler.prototype.validate = function (path, fn) {
	this.validationMethods[path] = fn;
	return this;
};


/**
 * Adds a validationError to the updateHandler; can be used before
 * `.process()` is called to handle errors generated by custom pre-
 * processing.
 *
 * @param {string} path that failed validation
 * @param {string} message to display
 * @param {string} error type (defaults to 'required')
 * @api public
 */

UpdateHandler.prototype.addValidationError = function (path, msg, type) {
	this.validationErrors[path] = {
		name: 'ValidatorError',
		path: path,
		message: msg,
		type: type || 'required',
	};
	return this;
};


/**
 * Processes data from req.body, req.query, or any data source.
 *
 * Options:
 * - fields (comma-delimited list or array of field paths)
 * - flashErrors (boolean, default false; whether to push validation errors to req.flash)
 * - ignoreNoedit (boolean, default false; whether to ignore noedit settings on fields)
 * - validationErrors (object; validation errors from previous form handling that should be included)
 *
 * @param {Object} data
 * @param {Object} options (can be comma-delimited list of fields) (optional)
 * @param {Function} callback (optional)
 * @api public
 */

UpdateHandler.prototype.process = function (data, options, callback) {

	var usingDefaultFields = false;

	if (typeof options === 'function') {
		callback = options;
		options = null;
	}

	if (typeof callback !== 'function') {
		callback = function () {};
	}

	// Initialise options

	if (!options) {
		options = {};
	} else if (typeof options === 'string') {
		options = { fields: options };
	}

	if (!options.fields) {
		options.fields = _.keys(this.list.fields);
		usingDefaultFields = true;
	} else if (typeof options.fields === 'string') {
		options.fields = options.fields.split(',').map(function (i) { return i.trim(); });
	}

	options.required = options.required || {};
	options.errorMessage = options.errorMessage || this.options.errorMessage;
	options.invalidMessages = options.invalidMessages || {};
	options.requiredMessages = options.requiredMessages || {};

	// Parse a string of required fields into field paths
	if (typeof options.required === 'string') {
		var requiredFields = options.required.split(',').map(function (i) { return i.trim(); });
		options.required = {};
		requiredFields.forEach(function (path) {
			options.required[path] = true;
		});
	}

	// Make sure fields with the required option set are included in the required paths
	options.fields.forEach(function (path) {
		var field = (path instanceof keystone.Field) ? path : this.list.field(path);
		if (field && field.required) {
			options.required[field.path] = true;
		}
	}, this);

	// TODO: The whole progress queue management code could be a lot neater...
	var actionQueue = [];
	var addValidationError = this.addValidationError.bind(this);
	var validationErrors = this.validationErrors;

	var progress = function (err) {
		if (err) {
			if (options.logErrors) {
				console.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');
				console.log(err);
			}
			callback(err, this.item, this);
		} else if (_.size(validationErrors)) {
			if (options.flashErrors) {
				this.req.flash('error', {
					type: 'ValidationError',
					title: options.errorMessage,
					list: _.map(validationErrors, 'message'),
				});
			}
			callback({
				message: 'Validation failed',
				name: 'ValidationError',
				errors: validationErrors,
			}, this.item, this);
		} else if (actionQueue.length) {
			// TODO: parallel queue handling for cloudinary uploads?
			actionQueue.pop()();
		} else {
			saveItem();
		}
	}.bind(this);

	var saveItem = function () {

		// Make current user available to pre/post save events
		this.item._req_user = this.user;

		this.item.save(function (err) {
			if (err) {
				if (err.name === 'ValidationError') {
					// don't log simple validation errors
					if (options.flashErrors) {
						this.req.flash('error', {
							type: 'ValidationError',
							title: options.errorMessage,
							list: _.map(err.errors, 'message'),
						});
					}
				} else {
					if (options.logErrors) {
						console.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');
						console.log(err);
					}
					if (options.flashErrors) {
						this.req.flash('error', 'There was an error saving your changes: ' + err.message + ' (' + err.name + (err.type ? ': ' + err.type : '') + ')');
					}
				}
			}
			return callback(err, this.item, this);
		}.bind(this));
	}.bind(this);

	async.forEach(options.fields, function (path, callback) {

		// console.log('Processing field ' + path);
		var message;

		var field = (path instanceof keystone.Field) ? path : this.list.field(path);
		var invalidated = false;

		if (!field) {
			throw new Error('UpdateHandler.process called with invalid field path: ' + path);
		}

		// skip uneditable fields
		if (usingDefaultFields && field.noedit && !options.ignoreNoedit) {
			// console.log('Skipping field ' + path + ' (noedit: true)');
			return callback();
		}

		// Some field types have custom behaviours for queueing or validation
		switch (field.type) {

			case 'localfile':
			case 'localfiles':
			case 'cloudinaryimage':
			case 'cloudinaryimages':
			case 'azurefile':
			case 's3file':
				actionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function (err) {
					if (err && options.flashErrors) {
						this.req.flash('error', field.label + ' upload failed - ' + err.message);
					}
					progress(err);
				}.bind(this)));
				break;

			case 'location':
				actionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function (err) {
					if (err && options.flashErrors) {
						this.req.flash('error', field.label + ' improve failed - ' + (err.status_text || err.status));
					}
					progress(err);
				}.bind(this)));
				break;

			case 'password':
				// passwords should only be set if a value is provided.
				// if no value is provided, as long as the field isn't required or empty, bail.
				if (!data[field.path] && (!options.required[field.path] || this.item.get(field.path))) {
					return callback();
				}
				// validate the password fields match, with a custom error message.
				if (data[field.path] !== data[field.paths.confirm]) {
					message = options.invalidMessages[field.path + '_match'] || 'Passwords must match';
					addValidationError(field.path, message);
					invalidated = true;
				}
				break;

		}

		// validate field input, unless it's already been invalidated by field-specific behaviour
		if (!invalidated && !field.inputIsValid(data)) {
			// console.log('Field ' + field.path + ' is invalid');
			message = options.invalidMessages[field.path] || field.options.invalidMessage || 'Please enter a valid ' + field.typeDescription + ' in the ' + field.label + ' field';
			addValidationError(field.path, message);
			invalidated = true;
		}

		// validate required fields, unless they've already been invalidated by field-specific behaviour
		if (!invalidated && options.required[field.path] && !field.inputIsValid(data, true, this.item) && !validationErrors[field.path]) {
			// console.log('Field ' + field.path + ' is required, but not provided.');
			if (!field.dependsOn || evalDependsOn(field.dependsOn, data)) {
				debug('validate dependsOn required', field.dependsOn);
				// field is required only if dependsOn is true
				message = options.requiredMessages[field.path] || field.options.requiredMessage || field.label + ' is required';
				addValidationError(field.path, message);
				invalidated = true;
			}

		}

		// check for a custom validation rule at the path, and run it (unless the field is already invalid)
		if (!invalidated && this.validationMethods[field.path]) {
			message = this.validationMethods[field.path](data);
			if (message) {
				addValidationError(field.path, message);
			}
			invalidated = true;
		}

		field.updateItem(this.item, data, callback);

	}.bind(this), function () {
		progress();
	});
};


/*!
 * Export class
 */

module.exports = UpdateHandler;
